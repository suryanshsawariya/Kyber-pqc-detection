import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext
import threading
import socket
import ssl
import time
import random
import statistics
import psutil  # For performance monitoring
import matplotlib.pyplot as plt
from io import BytesIO
from PIL import Image, ImageTk
import numpy as np

# ==========================
# Data Transmission Module
# ==========================
def create_secure_socket():
    context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH)
    context.load_verify_locations(cafile="server.crt")
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    secure_sock = context.wrap_socket(sock, server_hostname='localhost')
    return secure_sock

def server_gui(log_text):
    host = 'localhost'
    port = 9999
    context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
    context.load_cert_chain(certfile="server.crt", keyfile="server.key")

    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.bind((host, port))
    server_socket.listen(5)

    log_text.insert(tk.END, "üîµ Server is running and waiting for connection...\n ", "info")

    client_socket, addr = server_socket.accept()
    secure_socket = context.wrap_socket(client_socket, server_side=True)
    log_text.insert(tk.END, f"üîµ Connection established with {addr}\n", "info")

    data = secure_socket.recv(1024).decode()
    if data:
        log_text.insert(tk.END, f"üîµ Received: {data}\n", "highlight")
        secure_socket.send("Data received securely!".encode())
        log_text.insert(tk.END, "üü¢ Confirmation sent to client\n", "success")
    
    secure_socket.close()
    server_socket.close()

def client_gui(message, log_text):
    try:
        # Create a secure socket and connect to the server
        secure_socket = create_secure_socket()
        secure_socket.connect(('localhost', 9999))
        
        # Log the sent message
        log_text.insert(tk.END, f"üü° Sent message: {message}\n", "info")
        
        # Send the message to the server
        secure_socket.send(message.encode())
        
        # Receive acknowledgment from the server
        data = secure_socket.recv(1024).decode()
        
        # Log the server's response (receipt)
        log_text.insert(tk.END, f"üü¢ Acknowledgment from server: {data}\n", "success")
        
        # Print the sent message receipt
        log_text.insert(tk.END, f"üü¢ Message Sent Successfully: {message}\n", "highlight")
        
        secure_socket.close()
    except Exception as e:
        messagebox.showerror("Connection Error", str(e))


# ==========================
# Kyber PQC Simulation (without OQS)
# ==========================
def kyber_demo_gui(message, output_text):
    try:
        output_text.insert(tk.END, "üü† Simulating Kyber keys...\n", "info")

        public_key = random.getrandbits(256)  # Fake public key
        secret_key = random.getrandbits(256)  # Fake secret key
        output_text.insert(tk.END, f"Kyber Public Key: {hex(public_key)}\n", "info")

        ciphertext = random.getrandbits(256)  # Fake ciphertext
        shared_secret = random.getrandbits(256)  # Fake shared secret
        output_text.insert(tk.END, f"Ciphertext: {hex(ciphertext)}\n", "highlight")
        output_text.insert(tk.END, f"Shared Secret (Generated by Client): {hex(shared_secret)}\n", "info")

        recovered_shared_secret = shared_secret  # Assume the same secret
        output_text.insert(tk.END, f"Shared Secret (Recovered by Server): {hex(recovered_shared_secret)}\n", "success")

        if shared_secret == recovered_shared_secret:
            output_text.insert(tk.END, "‚úÖ Success! Shared secrets match.\n", "success")
        else:
            output_text.insert(tk.END, "‚ùå Error: Shared secrets do not match!\n", "error")

    except Exception as e:
        messagebox.showerror("Error", str(e))

# ==========================
# Quantum Key Distribution Module (Simulation)
# ==========================
def qkd_demo_gui(output_text):
    output_text.insert(tk.END, "üü£ Simulating Quantum Key Distribution (QKD)...\n", "info")
    key_length = 128
    alice_key = [random.randint(0, 1) for _ in range(key_length)]
    bob_key = alice_key[:]  # Assume perfect channel for simulation

    output_text.insert(tk.END, f"Alice's key: {alice_key}\n", "info")
    output_text.insert(tk.END, f"Bob's key: {bob_key}\n", "info")
    output_text.insert(tk.END, f"Generated keys match! Key length: {len(alice_key)} bits\n", "success")

# ==========================
# Benchmarking Module
# ==========================
def benchmark_function(func, output_text, iterations=10):
    times = []
    for _ in range(iterations):
        start_time = time.time()
        func()
        end_time = time.time()
        times.append(end_time - start_time)

    avg_time = statistics.mean(times)
    output_text.insert(tk.END, f"‚è± Average execution time over {iterations} runs: {avg_time:.6f} seconds\n", "highlight")
    return avg_time

def kyber_benchmark_gui(output_text):
    try:
        iterations = 10
        times_keygen = []
        times_encap = []
        times_decap = []

        for _ in range(iterations):
            start_time = time.time()
            public_key = random.getrandbits(256)  # Simulate keygen
            secret_key = random.getrandbits(256)
            times_keygen.append(time.time() - start_time)

            start_time = time.time()
            ciphertext = random.getrandbits(256)  # Simulate encapsulation
            shared_secret = random.getrandbits(256)
            times_encap.append(time.time() - start_time)

            start_time = time.time()
            recovered_shared_secret = shared_secret  # Simulate decapsulation
            times_decap.append(time.time() - start_time)

        avg_keygen_time = sum(times_keygen) / iterations
        avg_encap_time = sum(times_encap) / iterations
        avg_decap_time = sum(times_decap) / iterations

        output_text.insert(tk.END, f"‚è± Kyber Key Generation Time (avg): {avg_keygen_time:.6f} seconds\n", "highlight")
        output_text.insert(tk.END, f"‚è± Kyber Encryption Time (avg): {avg_encap_time:.6f} seconds\n", "highlight")
        output_text.insert(tk.END, f"‚è± Kyber Decryption Time (avg): {avg_decap_time:.6f} seconds\n", "highlight")
    except Exception as e:
        messagebox.showerror("Error", str(e))

def qkd_benchmark_gui(output_text):
    output_text.insert(tk.END, "Benchmarking QKD simulation...\n", "info")
    benchmark_function(lambda: qkd_demo_gui(output_text), output_text)

# ==========================
# Robustness Testing Module
# ==========================
def robustness_testing_gui(output_text):
    output_text.insert(tk.END, "üü° Running Robustness Testing for Kyber PQC...\n", "info")
    
    # Test 1: Corrupted Ciphertext
    try:
        corrupted_ciphertext = random.getrandbits(255)  # Corrupted ciphertext (1 bit shorter)
        output_text.insert(tk.END, f"Testing with corrupted ciphertext: {hex(corrupted_ciphertext)}\n", "info")
        # Simulate decryption failure with corrupted ciphertext
        output_text.insert(tk.END, "‚ùå Decryption failed as expected with corrupted ciphertext\n", "error")
    except Exception as e:
        output_text.insert(tk.END, f"Error during corrupted ciphertext test: {str(e)}\n", "error")
    
    # Test 2: Noise Injection
    try:
        noisy_shared_secret = random.getrandbits(256) ^ 0b101010  # Inject noise into the shared secret
        output_text.insert(tk.END, f"Testing with noise injected into shared secret: {hex(noisy_shared_secret)}\n", "info")
        # Simulate decryption failure due to noise in the shared secret
        output_text.insert(tk.END, "‚ùå Noise caused decryption mismatch\n", "error")
    except Exception as e:
        output_text.insert(tk.END, f"Error during noise injection test: {str(e)}\n", "error")
    
    # Test 3: Key Mismatch
    try:
        mismatched_key = random.getrandbits(256)
        output_text.insert(tk.END, f"Testing with mismatched key: {hex(mismatched_key)}\n", "info")
        # Simulate decryption failure due to key mismatch
        output_text.insert(tk.END, "‚ùå Key mismatch detected, decryption failed\n", "error")
    except Exception as e:
        output_text.insert(tk.END, f"Error during key mismatch test: {str(e)}\n", "error")


# ==========================
# Visual Analytics Module
# ==========================
def plot_graphs(output_text, data):
    plt.figure(figsize=(10, 6))
    plt.plot(data, marker='o')
    plt.title('Performance Over Iterations')
    plt.xlabel('Iterations')
    plt.ylabel('Time (seconds)')
    plt.grid(True)
    
    buf = BytesIO()
    plt.savefig(buf, format='png')
    buf.seek(0)
    img = Image.open(buf)
    img = ImageTk.PhotoImage(img)
    
    output_text.image_create(tk.END, image=img)
    output_text.image = img

# ==========================
# Security and Performance Analysis Module
# ==========================
def analyze_security_gui(output_text):
    pqc_strength = "Simulated strength based on lattice problems"
    qkd_security = "Unconditionally secure based on quantum mechanics"

    output_text.insert(tk.END, f"üîí PQC Security: {pqc_strength}\n", "highlight")
    output_text.insert(tk.END, f"üîí QKD Security: {qkd_security}\n", "highlight")

def analyze_performance_gui(output_text):
    output_text.insert(tk.END, "‚öô Analyzing performance...\n", "info")
    
    pqc_avg_time = benchmark_function(lambda: kyber_demo_gui("Test Message", output_text), output_text)
    qkd_avg_time = benchmark_function(lambda: qkd_demo_gui(output_text), output_text)
    
    memory_usage = psutil.Process().memory_info().rss / (1024 ** 2)  # Memory in MB
    cpu_usage = psutil.cpu_percent(interval=1)  # CPU usage over 1 second

    output_text.insert(tk.END, f"üíª Memory Usage: {memory_usage:.2f} MB\n", "info")
    output_text.insert(tk.END, f"üíª CPU Usage: {cpu_usage:.2f}%\n", "info")

# ==========================
# GUI Application
# ==========================
def apply_styles(root):
    style = ttk.Style()

    # Set the theme to 'clam' for customization
    style.theme_use("clam")

    # Main window background with a light blue and green mix
    root.configure(bg="#A9D7E4")  # Light blue for the background

    # Button styles with light green accent color
    style.configure("TButton",
                    background="#A8D08D",  # Light green for buttons
                    foreground="#2E4053",  # Dark blue-gray for text (professional look)
                    font=("Segoe UI", 12, "bold"),
                    padding=8, relief="flat")
    style.map("TButton",
              background=[("active", "#88C26D")],  # Slightly darker green when active
              relief=[("pressed", "sunken")])

    # Frame and Label styles with light green and blue tones
    style.configure("TFrame", background="#C9E3D8")  # Soft pastel light green for frames
    style.configure("TLabel",
                    background="#C9E3D8",  # Same soft light green
                    foreground="#2E4053",  # Dark blue-gray text for contrast
                    font=("Segoe UI", 12))

    # Notebook tab styling with light blue and green
    style.configure("TNotebook", background="#A9D7E4",  # Light blue for notebook
                    borderwidth=0)
    style.configure("TNotebook.Tab",
                    background="#A8D08D",  # Light green for tabs
                    foreground="#2E4053",  # Dark text for clarity
                    padding=10, font=("Segoe UI", 10, "bold"))
    style.map("TNotebook.Tab",
              background=[("selected", "#7CC689")],  # Slightly darker green for selected tab
              foreground=[("selected", "#FFFFFF")])  # White text for selected tab

    # Treeview styles with light green background and vibrant selection
    style.configure("Treeview", background="#C9E3D8",  # Soft pastel green background for treeview
                    foreground="#2E4053",  # Dark text
                    fieldbackground="#A8D08D")  # Light green for treeview fields
    style.map("Treeview", background=[("selected", "#7CC689")],  # Bright green for selected items
              foreground=[("selected", "#FFFFFF")])  # White text for selected items

    # Listbox styles with light pastel background and vibrant selection
    style.configure("Listbox",
                    background="#C9E3D8",  # Light green background
                    foreground="#2E4053",  # Dark gray text
                    selectbackground="#7CC689",  # Bright green selection background
                    selectforeground="#FFFFFF")  # White text on selection


def create_rounded_button(root, text, command=None):
    """Helper function to create a modern rounded button using a canvas."""
    frame = tk.Frame(root, bg="#f0f0f0")
    frame.pack(pady=10)

    canvas = tk.Canvas(frame, width=160, height=40, bg="#f0f0f0", bd=0, highlightthickness=0, relief="ridge")
    canvas.pack()

    # Create rounded rectangle
    button_bg = canvas.create_oval(10, 5, 150, 35, outline="#4CAF50", fill="#4CAF50")
    
    # Add text inside the button
    button_text = canvas.create_text(80, 20, text=text, fill="#FFFFFF", font=("Helvetica", 11, "bold"))

    def on_click(event):
        if command:
            command()

    canvas.tag_bind(button_text, "<Button-1>", on_click)
    canvas.tag_bind(button_bg, "<Button-1>", on_click)

    def on_hover(event):
        canvas.itemconfig(button_bg, fill="#388E3C")

    def off_hover(event):
        canvas.itemconfig(button_bg, fill="#4CAF50")

    # Hover effect
    canvas.bind("<Enter>", on_hover)
    canvas.bind("<Leave>", off_hover)

    return frame

def run_server(log_text):
    threading.Thread(target=server_gui, args=(log_text,), daemon=True).start()

def run_client(message_entry, log_text):
    message = message_entry.get()
    threading.Thread(target=client_gui, args=(message, log_text), daemon=True).start()

def kyber_run(message_entry, output_text):
    message = message_entry.get()
    threading.Thread(target=kyber_demo_gui, args=(message, output_text), daemon=True).start()

def main():
    root = tk.Tk()
    root.title("PQC & QKD Simulator")
    root.geometry("1000x600")
    
    apply_styles(root)

    notebook = ttk.Notebook(root)
    notebook.pack(fill="both", expand=True)

    tab1 = ttk.Frame(notebook)
    tab2 = ttk.Frame(notebook)
    tab3 = ttk.Frame(notebook)
    tab4 = ttk.Frame(notebook)
    tab5 = ttk.Frame(notebook)
    tab6 = ttk.Frame(notebook)  # New Robustness Testing Tab

    notebook.add(tab1, text="üîó Server & Client Communication")
    notebook.add(tab2, text="üîê Kyber PQC Demonstration")
    notebook.add(tab3, text="üîë QKD Simulation")
    notebook.add(tab4, text="‚öô Benchmarking")
    notebook.add(tab5, text="üîç Security & Performance Analysis")
    notebook.add(tab6, text="üõ° Robustness Testing")  # Adding Robustness Testing Tab

    # Server & Client Communication Tab
    header_label = ttk.Label(tab1, text="Server & Client Communication", font=("Helvetica", 14, "bold"))
    header_label.pack(pady=10)

    log_text = scrolledtext.ScrolledText(tab1, width=90, height=20, background="#1C2833", foreground="white", font=("Arial", 13))
    log_text.pack(padx=10, pady=10)

    # Color tags for different message types
    log_text.tag_configure("info", foreground="#3498DB")
    log_text.tag_configure("success", foreground="#2ECC71")
    log_text.tag_configure("highlight", foreground="#E74C3C")
    log_text.tag_configure("error", foreground="#E74C3C")

    server_button = ttk.Button(tab1, text="Run Server", command=lambda: run_server(log_text))
    server_button.pack(side="left", padx=5)

    client_button = ttk.Button(tab1, text="Run Client", command=lambda: run_client(message_entry, log_text))
    client_button.pack(side="left", padx=5)

    message_label = ttk.Label(tab1, text="Message to Send:")
    message_label.pack(pady=5)
    message_entry = ttk.Entry(tab1)
    message_entry.pack(pady=5, padx=10)

    # Kyber PQC Demonstration Tab
    header_label = ttk.Label(tab2, text="Kyber PQC Demonstration", font=("Helvetica", 16, "bold"))
    header_label.pack(pady=10)

    message_label = ttk.Label(tab2, text="Enter message:")
    message_label.pack(pady=10)
    message_entry = ttk.Entry(tab2)
    message_entry.pack(pady=5, padx=10)

    output_text = scrolledtext.ScrolledText(tab2, width=90, height=20, background="#1C2833", foreground="white", font=("Arial", 13))
    output_text.pack(padx=10, pady=10)

    output_text.tag_configure("info", foreground="#3498DB")
    output_text.tag_configure("success", foreground="#2ECC71")
    output_text.tag_configure("highlight", foreground="#E74C3C")
    output_text.tag_configure("error", foreground="#E74C3C")

    kyber_button = ttk.Button(tab2, text="Simulate Kyber", command=lambda: kyber_run(message_entry, output_text))
    kyber_button.pack(pady=10)

    # QKD Simulation Tab
    header_label = ttk.Label(tab3, text="Quantum Key Distribution (QKD) Simulation", font=("Helvetica", 16, "bold"))
    header_label.pack(pady=10)

    qkd_output_text = scrolledtext.ScrolledText(tab3, width=90, height=20, background="#1C2833", foreground="white", font=("Arial", 13))
    qkd_output_text.pack(pady=10)

    qkd_output_text.tag_configure("info", foreground="#3498DB")
    qkd_output_text.tag_configure("success", foreground="#2ECC71")
    qkd_output_text.tag_configure("highlight", foreground="#E74C3C")
    qkd_output_text.tag_configure("error", foreground="#E74C3C")

    qkd_button = ttk.Button(tab3, text="Run QKD Simulation", command=lambda: qkd_demo_gui(qkd_output_text))
    qkd_button.pack(pady=10)

    # Benchmarking Tab
    header_label = ttk.Label(tab4, text="Benchmarking", font=("Helvetica", 16, "bold"))
    header_label.pack(pady=10)

    benchmark_output_text = scrolledtext.ScrolledText(tab4, width=90, height=20, background="#1C2833", foreground="white", font=("Arial", 13))
    benchmark_output_text.pack(pady=10)

    benchmark_output_text.tag_configure("info", foreground="#3498DB")
    benchmark_output_text.tag_configure("success", foreground="#2ECC71")
    benchmark_output_text.tag_configure("highlight", foreground="#E74C3C")
    benchmark_output_text.tag_configure("error", foreground="#E74C3C")

    pqc_benchmark_button = ttk.Button(tab4, text="Run Kyber Benchmark", command=lambda: kyber_benchmark_gui(benchmark_output_text))
    pqc_benchmark_button.pack(side="left", padx=10)

    qkd_benchmark_button = ttk.Button(tab4, text="Run QKD Benchmark", command=lambda: qkd_benchmark_gui(benchmark_output_text))
    qkd_benchmark_button.pack(side="left", padx=10)

    # Security Analysis Tab
    header_label = ttk.Label(tab5, text="Security & Performance Analysis", font=("Helvetica", 16, "bold"))
    header_label.pack(pady=10)

    analysis_output_text = scrolledtext.ScrolledText(tab5, width=90, height=20, background="#1C2833", foreground="white", font=("Arial", 13))
    analysis_output_text.pack(padx=10, pady=10)

    analysis_output_text.tag_configure("info", foreground="#3498DB")
    analysis_output_text.tag_configure("success", foreground="#2ECC71")
    analysis_output_text.tag_configure("highlight", foreground="#E74C3C")
    analysis_output_text.tag_configure("error", foreground="#E74C3C")

    security_analysis_button = ttk.Button(tab5, text="Analyze Security", command=lambda: analyze_security_gui(analysis_output_text))
    security_analysis_button.pack(side="left", padx=10)

    performance_analysis_button = ttk.Button(tab5, text="Analyze Performance", command=lambda: analyze_performance_gui(analysis_output_text))
    performance_analysis_button.pack(side="left", padx=10)

    # Robustness Testing Tab
    header_label = ttk.Label(tab6, text="Robustness Testing", font=("Helvetica", 16, "bold"))
    header_label.pack(pady=10)

    robustness_output_text = scrolledtext.ScrolledText(tab6, width=90, height=20, background="#1C2833", foreground="white", font=("Arial", 13))
    robustness_output_text.pack(padx=10, pady=10)

    robustness_output_text.tag_configure("info", foreground="#3498DB")
    robustness_output_text.tag_configure("success", foreground="#2ECC71")
    robustness_output_text.tag_configure("highlight", foreground="#E74C3C")
    robustness_output_text.tag_configure("error", foreground="#E74C3C")

    robustness_test_button = ttk.Button(tab6, text="Run Robustness Test", command=lambda: robustness_testing_gui(robustness_output_text))
    robustness_test_button.pack(pady=10)


    root.mainloop()

if __name__ == "__main__":
    main()